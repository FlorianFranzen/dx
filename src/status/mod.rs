// Copyright 2017-2018 Parity Technologies (UK) Ltd.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//! This module implements the `/dx/status/0.1.0` protocol.
//!
//! It is based on the IPFS ping protocol and can be used as a simple application-layer
//! health check for connections of any [`Transport`]. It is the plan to extend it to a
//! full configuration status check in the future.
//!
//! # Usage
//!
//! The [`Status`] struct implements the [`NetworkBehaviour`] trait. When used with a [`Swarm`],
//! it will respond to inbound status requests and as necessary periodically send outbound
//! status requests on every established connection. If a configurable number of pings fail,
//! the connection will be closed.
//!
//! The `Status` network behaviour produces [`StatusEvent`]s, which may be consumed from the `Swarm`
//! by an application, e.g. to collect statistics.
//!
//! > **Note**: The status protocol does not keep otherwise idle connections alive,
//! > it only adds an additional condition for terminating the connection, namely
//! > a certain number of failed status requests.
//!
//! [`Swarm`]: libp2p_core::Swarm
//! [`Transport`]: libp2p_core::Transport

pub mod protocol;
pub mod handler;
pub mod helper;

pub use protocol::Payload;

pub use handler::{StatusConfig, StatusResult, StatusSuccess, StatusFailure};
use handler::StatusHandler;

pub use helper::generate_payload;


use std::collections::VecDeque;
use std::marker::PhantomData;

use futures::prelude::*;

use libp2p::core::{ConnectedPoint, Multiaddr, PeerId};
use libp2p::swarm::{NetworkBehaviour, NetworkBehaviourAction, PollParameters};
use libp2p::tokio_io::{AsyncRead, AsyncWrite};

use void::Void;


/// `Status` is a [`NetworkBehaviour`] that responds to inbound statuss and
/// periodically sends outbound statuss on every established connection.
///
/// See the crate root documentation for more information.
pub struct Status<TSubstream> {
    /// Configuration for outbound statuss.
    config: StatusConfig,
    /// Queue of events to yield to the swarm.
    events: VecDeque<StatusEvent>,
    _marker: PhantomData<TSubstream>,
}

/// Event generated by the `Status` network behaviour.
#[derive(Debug)]
pub struct StatusEvent {
    /// The peer ID of the remote.
    pub peer: PeerId,
    /// The result of an inbound or outbound status.
    pub result: StatusResult,
}

impl<TSubstream> Status<TSubstream> {
    /// Creates a new `Status` network behaviour with the given configuration.
    pub fn new(config: StatusConfig) -> Self {
        Status {
            config,
            events: VecDeque::new(),
            _marker: PhantomData,
        }
    }
}

impl<TSubstream> Default for Status<TSubstream> {
    fn default() -> Self {
        Status::new(StatusConfig::new( [0; 20] ))
    }
}

impl<TSubstream> NetworkBehaviour for Status<TSubstream>
where
    TSubstream: AsyncRead + AsyncWrite,
{
    type ProtocolsHandler = StatusHandler<TSubstream>;
    type OutEvent = StatusEvent;

    fn new_handler(&mut self) -> Self::ProtocolsHandler {
        StatusHandler::new(self.config.clone())
    }

    fn addresses_of_peer(&mut self, _peer_id: &PeerId) -> Vec<Multiaddr> {
        Vec::new()
    }

    fn inject_connected(&mut self, _: PeerId, _: ConnectedPoint) {}

    fn inject_disconnected(&mut self, _: &PeerId, _: ConnectedPoint) {}

    fn inject_node_event(&mut self, peer: PeerId, result: StatusResult) {
        self.events.push_front(StatusEvent { peer, result })
    }

    fn poll(&mut self, _: &mut impl PollParameters) -> Async<NetworkBehaviourAction<Void, StatusEvent>>
    {
        if let Some(e) = self.events.pop_back() {
            Async::Ready(NetworkBehaviourAction::GenerateEvent(e))
        } else {
            Async::NotReady
        }
    }
}
